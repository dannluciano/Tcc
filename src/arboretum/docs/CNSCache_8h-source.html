<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CNSCache.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<h1>GBDI Arboretum<br><small>Version Release 1</small></h1>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>CNSCache.h</h1><a href="CNSCache_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/**********************************************************************</span>
00002 <span class="comment">* GBDI Arboretum - Copyright (c) 2002-2004 GBDI-ICMC-USP</span>
00003 <span class="comment">*</span>
00004 <span class="comment">*                           Homepage: http://gbdi.icmc.usp.br/arboretum</span>
00005 <span class="comment">**********************************************************************/</span>
00006 <span class="comment">/* ====================================================================</span>
00007 <span class="comment"> * The GBDI-ICMC-USP Software License Version 1.0</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Copyright (c) 2004 Grupo de Bases de Dados e Imagens, Instituto de</span>
00010 <span class="comment"> * Ciências Matemáticas e de Computação, University of São Paulo -</span>
00011 <span class="comment"> * Brazil (the Databases and Image Group - Intitute of Matematical and </span>
00012 <span class="comment"> * Computer Sciences).  All rights reserved.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00015 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00016 <span class="comment"> * are met:</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00019 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00022 <span class="comment"> *    notice, this list of conditions and the following disclaimer in</span>
00023 <span class="comment"> *    the documentation and/or other materials provided with the</span>
00024 <span class="comment"> *    distribution.</span>
00025 <span class="comment"> *</span>
00026 <span class="comment"> * 3. The end-user documentation included with the redistribution,</span>
00027 <span class="comment"> *    if any, must include the following acknowledgment:</span>
00028 <span class="comment"> *       "This product includes software developed by Grupo de Bases</span>
00029 <span class="comment"> *        de Dados e Imagens, Instituto de Ciências Matemáticas e de</span>
00030 <span class="comment"> *        Computação, University of São Paulo - Brazil (the Databases </span>
00031 <span class="comment"> *        and Image Group - Intitute of Matematical and Computer </span>
00032 <span class="comment"> *        Sciences)"</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> *    Alternately, this acknowledgment may appear in the software itself,</span>
00035 <span class="comment"> *    if and wherever such third-party acknowledgments normally appear.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> * 4. The names of the research group, institute, university, authors</span>
00038 <span class="comment"> *    and collaborators must not be used to endorse or promote products</span>
00039 <span class="comment"> *    derived from this software without prior written permission.</span>
00040 <span class="comment"> *</span>
00041 <span class="comment"> * 5. The names of products derived from this software may not contain</span>
00042 <span class="comment"> *    the name of research group, institute or university, without prior</span>
00043 <span class="comment"> *    written permission of the authors of this software.</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00046 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00047 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00048 <span class="comment"> * DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OF THIS SOFTWARE OR</span>
00049 <span class="comment"> * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00050 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00051 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00052 <span class="comment"> * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00053 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00054 <span class="comment"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00055 <span class="comment"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00056 <span class="comment"> * SUCH DAMAGE.</span>
00057 <span class="comment"> *</span>
00058 <span class="comment"> * ====================================================================</span>
00059 <span class="comment"> *                                            http://gbdi.icmc.usp.br/</span>
00060 <span class="comment"> */</span>
00061  
00062 <span class="comment">//==============================================================================</span>
00063 <span class="comment">//  Project: CAMF - Complex objects Access Method Framework</span>
00064 <span class="comment">//  Arquivo: CNSCache.h</span>
00065 <span class="comment">//  Autor: Roberto Figueira Santos Filho</span>
00066 <span class="comment">//  Orientador: Caetano Traina Junior</span>
00067 <span class="comment">//  Data Inicial: 10/06/1997</span>
00068 <span class="comment">//  Versao Atual: 0.0</span>
00069 <span class="comment">//</span>
00070 <span class="comment">//  Descricao:</span>
00071 <span class="comment">//   Este arquivo classe CNSCache - Natural Selection Cache Class.</span>
00072 <span class="comment">//    A documentacao precisa ser refeita.</span>
00073 <span class="comment">//</span>
00074 <span class="comment">//    Importante -&gt; se o objeto da classe continente criar um novo registro,</span>
00075 <span class="comment">//  o metodo GMC_NovoNRgs(unsigned long reg, void **) deve ser chamado para que</span>
00076 <span class="comment">//  sejam atualizados os controles do cache e tornar a pagina deste registro</span>
00077 <span class="comment">//  ativa. Este metodo so deve ser chamado apos a criacao do registro fisico na</span>
00078 <span class="comment">//  base, mesmo que em branco, e terem sido feitas as alteracoes na mesma para</span>
00079 <span class="comment">//  refletir sua existencia. Fica por conta do usuario qualquer erro de</span>
00080 <span class="comment">//  concistencia.</span>
00081 <span class="comment">//</span>
00082 <span class="comment">// Modificacoes:</span>
00083 <span class="comment">//    Author: Roberto Figueira Santos Filho</span>
00084 <span class="comment">//    Date: 06/01/2001</span>
00085 <span class="comment">//    Description:</span>
00086 <span class="comment">//      - Translate the name of public methods to English;</span>
00087 <span class="comment">//      - The old version forces user to allocate the cache object at execution</span>
00088 <span class="comment">//      time, which means the needing of a reference to the cache. I changed the</span>
00089 <span class="comment">//      constructor to solve this. Because of that, prior to used a cache, the</span>
00090 <span class="comment">//      method MountCache must be exectuted.</span>
00091 <span class="comment">//      - Put all the class definition inside the header file. I don't like this</span>
00092 <span class="comment">//      approach, but it seems a requirement for class templates.</span>
00093 <span class="comment">//</span>
00094 <span class="comment">//==============================================================================</span>
00095 
00096 <span class="preprocessor">#ifndef CNSCACHEH</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define CNSCACHEH</span>
00098 <span class="preprocessor"></span>
00099 <span class="preprocessor">#include &lt;<a class="code" href="stCommon_8h.html">arboretum/stCommon.h</a>&gt;</span>
00100 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00101 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00102 
00103 <span class="comment">//#define CNSCACHE_CHECK</span>
00104 
00105 <span class="comment">//---------------- DEFINICAO DA CLASSE CNSCache -----------------</span>
00106 
00107 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00108"></a><a class="code" href="classCNSCache.html">00108</a> <span class="keyword">class </span><a class="code" href="classCNSCache.html">CNSCache</a> {
00109    <span class="keyword">public</span>:
00110       <span class="comment">//---- Prototipos ----</span>
00111       <a class="code" href="classCNSCache.html#a0">CNSCache</a>();
00112       <a class="code" href="classCNSCache.html#a1">~CNSCache</a>();
00113       <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a2">MountCache</a>(TpObjCntin *father, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> NRegs, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> FRot,
00114              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NPgs, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TamBuff);
00115       <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a3">ReadPage</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">void</span> **);
<a name="l00116"></a><a class="code" href="classCNSCache.html#a4">00116</a>       <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a4">WritePage</a>() {
00117       ListaPgs.Pagina[ListaPgs.PgEmUso].Escrita = 1;
00118       }<span class="comment">// fim do metodo writePage</span>
00119       <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a5">NewPage</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, <span class="keywordtype">void</span> **);
00120       <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a6">FlushCache</a>();
00121 
00122    <span class="keyword">private</span>:
<a name="l00123"></a><a class="code" href="CNSCache_8h.html#a0">00123</a> <span class="preprocessor">      #define TxCrescBlocos 51</span>
<a name="l00124"></a><a class="code" href="CNSCache_8h.html#a1">00124</a> <span class="preprocessor"></span><span class="preprocessor">      #define CNSCACHE_NIL 0xFFFFU</span>
00125 <span class="preprocessor"></span>      <span class="comment">//---- Tipos ----</span>
00126       <span class="comment">//-- estrutura para mapeamento de enderecos de registros</span>
00127       <span class="comment">//   para paginas em memoria</span>
00128       <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00129          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pPagina; <span class="comment">// vetor com RGS_POR_BLOCO posicoes</span>
00130          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> RgsUsados;
00131       } tBloco;
00132 
00133       <span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="comment">// tabela de mapeamento de enderecos</span>
00134          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TotBlocos;
00135          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *pBloco; <span class="comment">// vetor com TotBlocos posicoes</span>
00136          tBloco *Bloco; <span class="comment">// vetor com N_PAGINAS posicoes</span>
00137          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> LBlocoDispo;
00138       } tTME;
00139 
00140       <span class="comment">//-- estrutura para manter a lista de paginas do cache</span>
00141       <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00142          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> proxDaFila;
00143          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> antDaFila;
00144          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> IdxTotAcessos;
00145          <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> IdRegFisico;
00146          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  Escrita;
00147          <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *Page;
00148       } tPagina;
00149 
00150       <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00151          tPagina *Pagina; <span class="comment">// vetor com N_PAGINAS posicoes</span>
00152          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> LPgDispo;
00153          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PgEmUso;
00154       } tListaPgs;
00155 
00156       <span class="comment">//-- estrutura para manter o Gerenciador de Acessos aas paginas do Cache</span>
00157       <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00158          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TotAcessos; <span class="comment">// total de acessos</span>
00159          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> prox; <span class="comment">// proximo no da lista de totais de acessos</span>
00160          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ant; <span class="comment">// no anterior da lista de totais de acessos</span>
00161          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frontFilaPg; <span class="comment">// aponta para a pg da fila de pgs referenciada</span>
00162                      <span class="comment">// ha mais tempo. As paginas sao retiradas daqui.</span>
00163          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rearFilaPg; <span class="comment">// aponta para a pg da fila de pgs referenciada</span>
00164                     <span class="comment">// ha menos tempo. Novas paginas sao inseridas aqui.</span>
00165       } tLTotAcessos;
00166 
00167       <span class="keyword">typedef</span> <span class="keyword">struct </span>{
00168          tLTotAcessos *LTotAcessos; <span class="comment">// vetor com os totais de acessos, possui</span>
00169                               <span class="comment">// N_PAGINAS posicoes</span>
00170          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Cabeca; <span class="comment">// aponta para o de menor total - primeiro da lista</span>
00171          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> LDispo;
00172       } tGerAcessos;
00173 
00174       <span class="comment">//---- Variaveis ----</span>
00175       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> F_ROTACAO;
00176       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> RGS_POR_BLOCO;
00177       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N_PAGINAS;
00178 
00179       tTME TME;
00180       tListaPgs ListaPgs;
00181       tGerAcessos GerAcessos;
00182       TpObjCntin *ObjContinente; <span class="comment">// objeto que contem o cache</span>
00183       <span class="comment">//---- Prototipos ----</span>
00184       <span class="keywordtype">void</span> IncPagina(); <span class="comment">// incrementa o numero de acessos da pagina corrente</span>
00185       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ObtemPagina();
00186       <span class="keywordtype">void</span> TiraPgFila(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
00187       <span class="keywordtype">void</span> ColocaPgFila(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);
00188       <span class="keywordtype">void</span> NovoTotal(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;);
00189       <span class="keywordtype">void</span> UnMountCache();
00190 <span class="preprocessor">      #ifdef __CACHECHECK</span>
00191 <span class="preprocessor"></span>      <span class="keywordtype">long</span> checkCounter; <span class="comment">// deve ser usado para identificar o momento em que o</span>
00192                          <span class="comment">// erro ocorreu. Ao inves de ficar percorrendo o cache</span>
00193                          <span class="comment">// ate o erro (e isso pode implicar em MUITOS acessos),</span>
00194                          <span class="comment">// este contador eh incrementado e impresso quando um</span>
00195                          <span class="comment">// um erro na estrutura eh encontrado. Dai, basta o</span>
00196                          <span class="comment">// programador gerar um break quando o contador chegar</span>
00197                          <span class="comment">// no valor do erro novamente.</span>
00198       <span class="keywordtype">void</span> checkStructure(); <span class="comment">// checa a estrutura do cache em busca de erros</span>
00199                              <span class="comment">// util para debugar</span>
00200 <span class="preprocessor">      #endif</span>
00201 <span class="preprocessor"></span>};<span class="comment">//end class CNSCache</span>
00202 
00203 <span class="comment">//---------------------------------------------------------------------------</span>
00204 <span class="comment">// Declaracao dos metodos da classe CNSCache</span>
00205 <span class="comment">//---------------------------------------------------------------------------</span>
00206 
00207 <span class="comment">//==============================================================================</span>
00208 <span class="comment">// Metodo: CNSCache() - construtor. Sem efeito.</span>
00209 <span class="comment">//==============================================================================</span>
00210 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00211"></a><a class="code" href="classCNSCache.html#a0">00211</a> <a class="code" href="classCNSCache.html#a0">CNSCache&lt;TpObjCntin&gt;::CNSCache</a>() {
00212    ObjContinente = NULL; <span class="comment">// indica que nenhum cache foi criado ainda</span>
00213 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::CNSCache</span>
00214 
00215 <span class="comment">//==============================================================================</span>
00216 <span class="comment">// Metodo: ~CNSCache()</span>
00217 <span class="comment">//==============================================================================</span>
00218 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00219"></a><a class="code" href="classCNSCache.html#a1">00219</a> <a class="code" href="classCNSCache.html#a1">CNSCache&lt;TpObjCntin&gt;::~CNSCache</a>() {
00220    UnMountCache();
00221 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::~CNSCache</span>
00222 
00223 <span class="comment">//==============================================================================</span>
00224 <span class="comment">// Metodo: MountCache(tFileMngr *father, unsigned long NRegs, unsigned char</span>
00225 <span class="comment">//           FRot, unsigned int NPgs, unsigned long TamBuff)</span>
00226 <span class="comment">//==============================================================================</span>
00227 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00228"></a><a class="code" href="classCNSCache.html#a2">00228</a> <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a2">CNSCache&lt;TpObjCntin&gt;::MountCache</a>(TpObjCntin *father, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> NRegs,
00229            <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> FRot, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NPgs, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> TamBuff) {
00230    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i, j;
00231    <span class="keywordtype">int</span> k;
00232 
00233    <span class="keywordflow">if</span> (ObjContinente) {
00234       UnMountCache();
00235    }
00236 
00237    <span class="comment">// inicializando parametros de configuracao do cache - InicPar()</span>
00238    F_ROTACAO = FRot;
00239    RGS_POR_BLOCO = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(1 &lt;&lt; F_ROTACAO);
00240    N_PAGINAS = NPgs;
00241 
00242    <span class="comment">// inicializando TME</span>
00243    TME.TotBlocos = (NRegs &gt;&gt; F_ROTACAO) + <a class="code" href="CNSCache_8h.html#a0">TxCrescBlocos</a>;
00244    TME.pBloco = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[TME.TotBlocos];
00245    <span class="keywordflow">for</span> (i = 0; i &lt; TME.TotBlocos; TME.pBloco[i++] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>);
00246    TME.Bloco = <span class="keyword">new</span> tBloco[N_PAGINAS];
00247    <span class="keywordflow">for</span> (i = 0; i &lt; N_PAGINAS; i++){
00248       TME.Bloco[i].pPagina = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[RGS_POR_BLOCO];
00249       <span class="keywordflow">for</span> (k = 1; k &lt; RGS_POR_BLOCO; TME.Bloco[i].pPagina[k++] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>);
00250       TME.Bloco[i].RgsUsados = 0;
00251       TME.Bloco[i].pPagina[0] = i + 1; <span class="comment">// se bloco nao usado a posicao 0 aponta</span>
00252                                 <span class="comment">// para o proximo disponivel - economiza memoria</span>
00253    } <span class="comment">// fim do for</span>
00254    TME.Bloco[N_PAGINAS - 1].pPagina[0] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00255    TME.LBlocoDispo = 0;
00256 
00257    <span class="comment">// inicializando ListaPgs</span>
00258    ListaPgs.Pagina = <span class="keyword">new</span> tPagina[N_PAGINAS];
00259    <span class="keywordflow">for</span> (i = 0; i &lt; N_PAGINAS; i++){
00260       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *paux;
00261 
00262       ListaPgs.Pagina[i].proxDaFila = i + 1;
00263       ListaPgs.Pagina[i].antDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00264       ListaPgs.Pagina[i].IdxTotAcessos = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00265       ListaPgs.Pagina[i].IdRegFisico = 0xFFFFFFFF;
00266       ListaPgs.Pagina[i].Escrita = 0;
00267       ListaPgs.Pagina[i].Page = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>  [TamBuff];
00268       paux = ListaPgs.Pagina[i].Page;
00269       <span class="keywordflow">for</span> (j = 0; j &lt; TamBuff; *paux++ = <span class="charliteral">'\0'</span>, j++);
00270    } <span class="comment">// fim do for</span>
00271    ListaPgs.Pagina[N_PAGINAS - 1].proxDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00272    ListaPgs.LPgDispo = 0;
00273    ListaPgs.PgEmUso = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00274 
00275    <span class="comment">// inicializando GerAcessos</span>
00276    GerAcessos.LTotAcessos = <span class="keyword">new</span> tLTotAcessos[N_PAGINAS];
00277    <span class="keywordflow">for</span> (i = 0; i &lt; N_PAGINAS; i++){
00278       GerAcessos.LTotAcessos[i].TotAcessos = 0;
00279       GerAcessos.LTotAcessos[i].prox = i + 1;
00280       GerAcessos.LTotAcessos[i].ant = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00281       GerAcessos.LTotAcessos[i].frontFilaPg =
00282             GerAcessos.LTotAcessos[i].rearFilaPg = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00283    } <span class="comment">// fim do for</span>
00284    GerAcessos.LTotAcessos[N_PAGINAS - 1].prox = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00285    GerAcessos.Cabeca = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00286    GerAcessos.LDispo = 0;
00287 
00288    <span class="comment">// inicializando parametros restantes</span>
00289    ObjContinente = father;
00290 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::MountCache</span>
00291 
00292 <span class="comment">//==============================================================================</span>
00293 <span class="comment">// Metodo: void ReadPage(pal4, void **)</span>
00294 <span class="comment">//==============================================================================</span>
00295 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00296"></a><a class="code" href="classCNSCache.html#a3">00296</a> <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a3">CNSCache&lt;TpObjCntin&gt;::ReadPage</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reg, <span class="keywordtype">void</span> **page) {
00297    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bloco = (reg &gt;&gt; F_ROTACAO);
00298    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pBloco = TME.pBloco[bloco];
00299    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bit = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(reg - (bloco &lt;&lt; F_ROTACAO));
00300    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPg = ((pBloco != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) ?
00301                                (TME.Bloco[pBloco].pPagina[bit]) : <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>);
00302 
00303    <span class="keywordflow">if</span> (pPg != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>){ <span class="comment">// a pagina ja esta na memoria</span>
00304       ListaPgs.PgEmUso = pPg;
00305       IncPagina(); <span class="comment">// incrementa a pagina em uso</span>
00306       *page = (<span class="keywordtype">void</span> *)ListaPgs.Pagina[pPg].Page;
00307       <span class="keywordflow">return</span>;
00308    } <span class="comment">// fim do then</span>
00309    <span class="keywordflow">else</span> { <span class="comment">// o registro nao esta na memoria</span>
00310       pPg = ObtemPagina();
00311       <span class="comment">// obtem registro da base</span>
00312       ObjContinente-&gt;DiskReadPage(reg, ListaPgs.Pagina[pPg].Page);
00313       ListaPgs.PgEmUso = pPg;
00314       ListaPgs.Pagina[pPg].IdRegFisico = reg;
00315 
00316       <span class="comment">//    IncPagina(); // incrementa a pagina em uso mesmo que seja nova, pois evita</span>
00317              <span class="comment">// que sempre as mesmas paginas sejam liberadas</span>
00318       *page = (<span class="keywordtype">void</span> *)ListaPgs.Pagina[pPg].Page;
00319 
00320       <span class="comment">// atualiza TME</span>
00321       <span class="comment">// IMPORTANTE: o teste abaixo nao pode ser "if (pBloco == CNSCACHE_NIL)"!</span>
00322       <span class="comment">// Observe que se TME.pBloco[bloco] possuir no minimo um registro, pBloco</span>
00323       <span class="comment">// e diferente de CNSCACHE_NIL. Porem, se a pagina obtida coincidir com o</span>
00324       <span class="comment">// registro de TME.pBloco[bloco] (que so contem este registro),</span>
00325       <span class="comment">// TME.pBloco[bloco] passa a ser CNSCACHE_NILL (ver // IMPORTANTE REF em</span>
00326       <span class="comment">// ObtemPagina()), gerando erro com relacao a pBloco que antes era diferente</span>
00327       <span class="comment">// de CNSCACHE_NIL, visto que existia um registro neste bloco.</span>
00328       <span class="keywordflow">if</span> (TME.pBloco[bloco] == <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>){ <span class="comment">// nao existe nenhum registro deste</span>
00329                                             <span class="comment">// bloco na memoria</span>
00330          <span class="comment">// obter um bloco livre e incluir no ponteiro de blocos</span>
00331          pBloco = TME.LBlocoDispo;
00332          <span class="comment">// o teste abaixo pode ser retirado, se o cache estiver funcionando</span>
00333          <span class="comment">// corretamentepara aumentar desempenho</span>
00334          <span class="keywordflow">if</span> (pBloco == <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) { <span class="comment">//nunca deve acontecer - erro de logica</span>
00335             printf(<span class="stringliteral">"CNSCache::GMC_le - Erro ao tentar obter um bloco"</span>);
00336             printf(<span class="stringliteral">" livre!\n"</span>);
00337             exit(1);
00338          } <span class="comment">// fim do if</span>
00339          TME.LBlocoDispo = TME.Bloco[pBloco].pPagina[0];
00340          TME.Bloco[pBloco].pPagina[0] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00341          TME.Bloco[pBloco].RgsUsados = 0;
00342          TME.pBloco[bloco] = pBloco;
00343       } <span class="comment">// fim do if</span>
00344       TME.Bloco[pBloco].pPagina[bit] = pPg;
00345       TME.Bloco[pBloco].RgsUsados++;
00346    } <span class="comment">// fim do if</span>
00347 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::ReadPage</span>
00348 
00349 <span class="comment">//==============================================================================</span>
00350 <span class="comment">// Metodo: void NewPage(unsigned long reg, void **page)</span>
00351 <span class="comment">//==============================================================================</span>
00352 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00353"></a><a class="code" href="classCNSCache.html#a5">00353</a> <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a5">CNSCache&lt;TpObjCntin&gt;::NewPage</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reg, <span class="keywordtype">void</span> **page) {
00354    <span class="keywordflow">if</span> (reg &gt;=  (TME.TotBlocos * RGS_POR_BLOCO)) { <span class="comment">// estouro do numero de blocos</span>
00355       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> novoTotal = TME.TotBlocos + <a class="code" href="CNSCache_8h.html#a0">TxCrescBlocos</a>;
00356       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> i;
00357 
00358       TME.pBloco = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)realloc(TME.pBloco,
00359                                               <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) * novoTotal);
00360       <span class="keywordflow">for</span> (i = TME.TotBlocos; i &lt; novoTotal; TME.pBloco[i++] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>);
00361       TME.TotBlocos = novoTotal;
00362    } <span class="comment">// fim do if</span>
00363    <a class="code" href="classCNSCache.html#a3">ReadPage</a>(reg, page);
00364 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::NewPage</span>
00365 
00366 <span class="comment">//==============================================================================</span>
00367 <span class="comment">// Metodo: void FlushCache()</span>
00368 <span class="comment">// Descarrega as paginas alteradas em disco</span>
00369 <span class="comment">//==============================================================================</span>
00370 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
<a name="l00371"></a><a class="code" href="classCNSCache.html#a6">00371</a> <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html#a6">CNSCache&lt;TpObjCntin&gt;::FlushCache</a>() {
00372    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
00373 
00374    i = GerAcessos.Cabeca;
00375    <span class="keywordflow">while</span> (i != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00376       j = GerAcessos.LTotAcessos[i].rearFilaPg;
00377       <span class="keywordflow">while</span> (j != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00378          <span class="keywordflow">if</span> (ListaPgs.Pagina[j].Escrita) {
00379             ObjContinente-&gt;DiskWritePage(ListaPgs.Pagina[j].IdRegFisico,
00380                                          ListaPgs.Pagina[j].Page);
00381             ListaPgs.Pagina[j].Escrita = 0;
00382          }
00383          <span class="comment">// fim do if</span>
00384          j = ListaPgs.Pagina[j].proxDaFila;
00385       } <span class="comment">// fim do while</span>
00386       i = GerAcessos.LTotAcessos[i].prox;
00387    } <span class="comment">// fim do while</span>
00388 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::FlushCache</span>
00389 
00390 <span class="comment">//==============================================================================</span>
00391 <span class="comment">// Metodo: void IncPagina()</span>
00392 <span class="comment">// incrementa o numero de acessos da pagina corrente</span>
00393 <span class="comment">//==============================================================================</span>
00394 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00395 <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::IncPagina</a>() {
00396    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgEmUso = ListaPgs.PgEmUso;
00397    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAces = ListaPgs.Pagina[pPgEmUso].IdxTotAcessos;
00398    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pProxTotAces = GerAcessos.LTotAcessos[pTotAces].prox;
00399 
00400    <span class="keywordflow">if</span> (pProxTotAces != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) { <span class="comment">// este nao e o ultimo TotAcessos</span>
00401       <span class="keywordflow">if</span> ((GerAcessos.LTotAcessos[pTotAces].TotAcessos + 1) ==
00402            GerAcessos.LTotAcessos[pProxTotAces].TotAcessos) {
00403             <span class="comment">// ProxTotAcessos e um a mais que o atual</span>
00404          TiraPgFila(pPgEmUso, pTotAces);
00405          ColocaPgFila(pPgEmUso, pProxTotAces);
00406       } <span class="comment">// fim do then</span>
00407       <span class="keywordflow">else</span> { <span class="comment">// ProxTotAcessos e mais do que um a mais que o atual</span>
00408          <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].frontFilaPg ==
00409              GerAcessos.LTotAcessos[pTotAces].rearFilaPg) {
00410             <span class="comment">// esta e a unica pagina neste TotAcessos e o total seguinte e</span>
00411             <span class="comment">// maior do que este incrementado, basta incrementar o total</span>
00412             GerAcessos.LTotAcessos[pTotAces].TotAcessos++;
00413          }<span class="keywordflow">else</span> { <span class="comment">// existem outras paginas na fila deste TotAcessos e o total</span>
00414             <span class="comment">// seguinte e maior do que este incrementado. Um novo total deve ser</span>
00415             <span class="comment">// criado e esta pagina deve ser transferida para ele.</span>
00416             TiraPgFila(pPgEmUso, pTotAces);
00417             NovoTotal(pPgEmUso, pTotAces); <span class="comment">// pTotAces e alterado retornando o novo</span>
00418          } <span class="comment">// fim do if</span>
00419          <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].TotAcessos &gt; 0xFFEF) {
00420             <span class="comment">// esta proximo do valor maximo, todos os totais sao reajustados</span>
00421             <span class="comment">// a comparacao foi feita com 0xFFEF e nao com 0xFFFF por seguranca</span>
00422             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pAux = GerAcessos.Cabeca;
00423             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> novoTot = 1;
00424 
00425             <span class="keywordflow">while</span> (pAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00426                GerAcessos.LTotAcessos[pAux].TotAcessos = novoTot++;
00427                pAux = GerAcessos.LTotAcessos[pAux].prox;
00428             } <span class="comment">// fim do while</span>
00429          } <span class="comment">//fim do if</span>
00430       } <span class="comment">// fim do if</span>
00431    }<span class="keywordflow">else</span>{ <span class="comment">// este e o ultimo TotAcessos</span>
00432       <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].frontFilaPg ==
00433           GerAcessos.LTotAcessos[pTotAces].rearFilaPg) {
00434           <span class="comment">// esta e a unica pagina neste TotAcessos e o total seguinte e</span>
00435           <span class="comment">// maior do que este incrementado, basta incrementar o total</span>
00436          GerAcessos.LTotAcessos[pTotAces].TotAcessos++;
00437       }<span class="keywordflow">else</span> { <span class="comment">// existem outras paginas na fila deste TotAcessos e o total</span>
00438          <span class="comment">// seguinte e maior do que este incrementado. Um novo total deve ser</span>
00439          <span class="comment">// criado e esta pagina deve ser transferida para ele.</span>
00440          TiraPgFila(pPgEmUso, pTotAces);
00441          NovoTotal(pPgEmUso, pTotAces); <span class="comment">// pTotAces e alterado retornando o novo</span>
00442       } <span class="comment">// fim do if</span>
00443       <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].TotAcessos &gt; 0xFFEF) {
00444          <span class="comment">// esta proximo do valor maximo, todos os totais sao reajustados</span>
00445          <span class="comment">// a comparacao foi feita com 0xFFEF e nao com 0xFFFF por seguranca</span>
00446          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pAux = GerAcessos.Cabeca;
00447          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> novoTot = 1;
00448 
00449          <span class="keywordflow">while</span> (pAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00450             GerAcessos.LTotAcessos[pAux].TotAcessos = novoTot++;
00451             pAux = GerAcessos.LTotAcessos[pAux].prox;
00452          } <span class="comment">// fim do while</span>
00453       } <span class="comment">//fim do if</span>
00454    } <span class="comment">// fim do if</span>
00455 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::IncPagina</span>
00456 
00457 <span class="comment">//==============================================================================</span>
00458 <span class="comment">// Metodo: unsigned int ObtemPagina()</span>
00459 <span class="comment">//==============================================================================</span>
00460 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00461 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::ObtemPagina</a>() {
00462    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgLivre = ListaPgs.LPgDispo;
00463    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAces;
00464 
00465    <span class="keywordflow">if</span> (pPgLivre != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>){ <span class="comment">// ainda existe uma pagina livre no cache</span>
00466       ListaPgs.LPgDispo = ListaPgs.Pagina[pPgLivre].proxDaFila;
00467       ListaPgs.Pagina[pPgLivre].proxDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00468       <span class="keywordflow">if</span> (GerAcessos.Cabeca == <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) { <span class="comment">// este e o primeiro total a ser incluido</span>
00469          pTotAces = GerAcessos.LDispo;
00470          GerAcessos.LDispo = GerAcessos.LTotAcessos[pTotAces].prox;
00471          GerAcessos.LTotAcessos[pTotAces].prox = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00472          GerAcessos.Cabeca = pTotAces;
00473          GerAcessos.LTotAcessos[pTotAces].frontFilaPg =
00474                  GerAcessos.LTotAcessos[pTotAces].rearFilaPg = pPgLivre;
00475          <span class="comment">// GerAcessos.LTotAcessos[pTotAces].TotAcessos ja vale 0,</span>
00476          <span class="comment">// nao perder tempo inicializando aqui</span>
00477          ListaPgs.Pagina[pPgLivre].IdxTotAcessos = pTotAces;
00478       }<span class="keywordflow">else</span> { <span class="comment">// ja existe pelo menos um TotAcessos, a pPgLivre sera incluida</span>
00479          <span class="comment">// na fila de paginas do menor TotAcessos (GerAcessos.Cabeca) e nao</span>
00480          <span class="comment">// em um TotAcessos com 0 para que nao haja uma distancia muito</span>
00481          <span class="comment">// grande entre o atual e o proximo. A inclusao na fila e sempre</span>
00482          <span class="comment">// no GerAcessos.LTotAcessos[pTotAces].rearFilaPg</span>
00483          ColocaPgFila(pPgLivre, GerAcessos.Cabeca);
00484       }<span class="comment">// fim do if</span>
00485       <span class="keywordflow">return</span> (pPgLivre);
00486    }<span class="keywordflow">else</span> { <span class="comment">// nao existe pagina livre no cache. Retira pagina acessada a mais</span>
00487            <span class="comment">// tempo da fila de paginas que possui menor frequencia de acessos</span>
00488       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> reg;
00489       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bloco;
00490       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pBloco;
00491       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bit;
00492       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgAnt, pPgRear, pPgFrontProxTot;
00493       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pProxTotAces;
00494 
00495       pTotAces = GerAcessos.Cabeca;
00496       pPgLivre = GerAcessos.LTotAcessos[pTotAces].frontFilaPg;
00497       <span class="keywordflow">if</span> (ListaPgs.Pagina[pPgLivre].Escrita) {
00498          ObjContinente-&gt;DiskWritePage(ListaPgs.Pagina[pPgLivre].IdRegFisico,
00499                                       ListaPgs.Pagina[pPgLivre].Page);
00500          ListaPgs.Pagina[pPgLivre].Escrita = 0;
00501       } <span class="comment">// fim do if</span>
00502       reg = ListaPgs.Pagina[pPgLivre].IdRegFisico;
00503       bloco = (reg &gt;&gt; F_ROTACAO);
00504       pBloco = TME.pBloco[bloco];
00505       bit = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(reg - (bloco &lt;&lt; F_ROTACAO));
00506       TME.Bloco[pBloco].pPagina[bit] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00507       TME.Bloco[pBloco].RgsUsados--;
00508       <span class="comment">// IMPORTANTE REF : referencia feita por GCM_le sobre tornar</span>
00509       <span class="comment">// TME.pBloco[bloco] = CNSCACHE_NIL quando o bloco da pagina que foi retirada</span>
00510       <span class="comment">// coincide com o bloco da pagina a ser inserida (ver GCM_le).</span>
00511       <span class="keywordflow">if</span> (!TME.Bloco[pBloco].RgsUsados) { <span class="comment">// TME.Bloco[pBloco].RgsUsados = 0,</span>
00512                   <span class="comment">// o bloco pBloco nao possui mais nenhum registro em</span>
00513                         <span class="comment">// memoria. Deve ser liberado entao.</span>
00514          TME.Bloco[pBloco].pPagina[0] = TME.LBlocoDispo;<span class="comment">//inclui na lista de dispo</span>
00515          TME.LBlocoDispo = pBloco;
00516          TME.pBloco[bloco] = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00517       } <span class="comment">// fim do if</span>
00518       <span class="comment">// tira o no da frente da fila e coloca no fim, no mesmo total.</span>
00519       <span class="comment">// primeiro verifica se so existe uma pg na fila: se so for 1 pg, nao faz</span>
00520       <span class="comment">// nada; se forem mais de 1 pgs, tira a da frente e reinsere no fim da fila.</span>
00521       <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].frontFilaPg !=
00522           GerAcessos.LTotAcessos[pTotAces].rearFilaPg) {<span class="comment">//existe + de 1 pg na fila</span>
00523          pPgAnt = ListaPgs.Pagina[pPgLivre].antDaFila;
00524          GerAcessos.LTotAcessos[pTotAces].frontFilaPg = pPgAnt;
00525          ListaPgs.Pagina[pPgAnt].proxDaFila =
00526                ListaPgs.Pagina[pPgLivre].antDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00527          ListaPgs.Pagina[pPgLivre].proxDaFila = pPgRear =
00528                GerAcessos.LTotAcessos[pTotAces].rearFilaPg;
00529          GerAcessos.LTotAcessos[pTotAces].rearFilaPg =
00530                ListaPgs.Pagina[pPgRear].antDaFila = pPgLivre;
00531       }
00532       <span class="comment">// incrementa o total desta fila para nao obter uma retirada viciosa.</span>
00533       <span class="comment">// Se o total seguinte for o atual + 1, a fila atual sera incluida</span>
00534       <span class="comment">// na frente da outra, mantendo a ordem em que as paginas seriam retiradas,</span>
00535       <span class="comment">// mas acrescentando as outras paginas para nao obter uma retirada viciosa.</span>
00536       <span class="comment">// Caso contrario, o total atual e incrementado de um.</span>
00537       pProxTotAces = GerAcessos.LTotAcessos[pTotAces].prox;
00538       <span class="keywordflow">if</span> (pProxTotAces != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) { <span class="comment">// este nao e o ultimo TotAcessos</span>
00539          <span class="keywordflow">if</span> ((GerAcessos.LTotAcessos[pTotAces].TotAcessos + 1) ==
00540               GerAcessos.LTotAcessos[pProxTotAces].TotAcessos) {
00541             <span class="comment">// ProxTotAcessos e um a mais que o atual, a fila atual e incluida</span>
00542             <span class="comment">// no final da proxima fila, e o total atual sera disponibilizado</span>
00543             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgAux = pPgLivre;
00544 
00545             <span class="keywordflow">while</span> (pPgAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) { <span class="comment">// atualiza o indice de totais das</span>
00546                         <span class="comment">// paginas da fila atual para apontar para o novo indice</span>
00547                ListaPgs.Pagina[pPgAux].IdxTotAcessos = pProxTotAces;
00548                pPgAux = ListaPgs.Pagina[pPgAux].proxDaFila;
00549             }<span class="comment">// fim do while</span>
00550             pPgFrontProxTot = GerAcessos.LTotAcessos[pProxTotAces].frontFilaPg;
00551             ListaPgs.Pagina[pPgLivre].antDaFila = pPgFrontProxTot;
00552             ListaPgs.Pagina[pPgFrontProxTot].proxDaFila = pPgLivre;
00553             GerAcessos.LTotAcessos[pProxTotAces].frontFilaPg =
00554                        GerAcessos.LTotAcessos[pTotAces].frontFilaPg;
00555             GerAcessos.LTotAcessos[pTotAces].rearFilaPg = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00556             GerAcessos.LTotAcessos[pTotAces].frontFilaPg = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00557             GerAcessos.Cabeca = pProxTotAces;
00558             GerAcessos.LTotAcessos[pProxTotAces].ant = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00559             GerAcessos.LTotAcessos[pTotAces].TotAcessos = 0;
00560             GerAcessos.LTotAcessos[pTotAces].prox = GerAcessos.LDispo;
00561             GerAcessos.LDispo = pTotAces;
00562          }<span class="keywordflow">else</span> { <span class="comment">// ProxTotAcessos e mais do que um a mais que o atual</span>
00563                  <span class="comment">// basta incrementar o total</span>
00564             GerAcessos.LTotAcessos[pTotAces].TotAcessos++;
00565             <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].TotAcessos &gt; 0xFFEF) {
00566             <span class="comment">// esta proximo do valor maximo, todos os totais sao reajustados</span>
00567             <span class="comment">// a comparacao foi feita com 0xFFEF e nao com 0xFFFF por seguranca</span>
00568                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pAux = GerAcessos.Cabeca;
00569                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> novoTot = 1;
00570 
00571                <span class="keywordflow">while</span> (pAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00572                   GerAcessos.LTotAcessos[pAux].TotAcessos = novoTot++;
00573                   pAux = GerAcessos.LTotAcessos[pAux].prox;
00574                } <span class="comment">// fim do while</span>
00575             } <span class="comment">//fim do if</span>
00576          } <span class="comment">// fim do if</span>
00577       }<span class="keywordflow">else</span>{ <span class="comment">// este e o ultimo TotAcessos, basta incrementar o total</span>
00578          GerAcessos.LTotAcessos[pTotAces].TotAcessos++;
00579          <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].TotAcessos &gt; 0xFFEF) {
00580             <span class="comment">// esta proximo do valor maximo, todos os totais sao reajustados</span>
00581             <span class="comment">// a comparacao foi feita com 0xFFEF e nao com 0xFFFF por seguranca</span>
00582             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pAux = GerAcessos.Cabeca;
00583             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> novoTot = 1;
00584 
00585             <span class="keywordflow">while</span> (pAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00586                GerAcessos.LTotAcessos[pAux].TotAcessos = novoTot++;
00587                pAux = GerAcessos.LTotAcessos[pAux].prox;
00588             }<span class="comment">// fim do while</span>
00589          } <span class="comment">//fim do if</span>
00590       } <span class="comment">// fim do if</span>
00591       <span class="keywordflow">return</span> (pPgLivre); <span class="comment">// o total de acessos a essa pg sera incrementado depois</span>
00592    }<span class="comment">// fim do if</span>
00593 }<span class="comment">//end int CNSCache&lt;TpObjCntin&gt;::ObtemPagina</span>
00594 
00595 <span class="comment">//==============================================================================</span>
00596 <span class="comment">// Metodo: void TiraPgFila(unsigned int pPg, unsigned int pTotAces)</span>
00597 <span class="comment">//==============================================================================</span>
00598 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00599 <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;:: TiraPgFila</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPg,
00600                                        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAces) {
00601    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgAux;
00602    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAcesAux;
00603 
00604    <span class="keywordflow">if</span> (GerAcessos.LTotAcessos[pTotAces].frontFilaPg ==
00605        GerAcessos.LTotAcessos[pTotAces].rearFilaPg) {<span class="comment">//so existe essa pg na fila</span>
00606       pTotAcesAux = GerAcessos.LTotAcessos[pTotAces].ant;
00607       <span class="keywordflow">if</span> (pTotAcesAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) <span class="comment">// existe total anterior</span>
00608          GerAcessos.LTotAcessos[pTotAcesAux].prox =
00609                                   GerAcessos.LTotAcessos[pTotAces].prox;
00610       <span class="keywordflow">else</span> <span class="comment">// nao existe total anterior, este e o primeiro</span>
00611          GerAcessos.Cabeca = GerAcessos.LTotAcessos[pTotAces].prox;
00612 
00613       pTotAcesAux = GerAcessos.LTotAcessos[pTotAces].prox;
00614       <span class="keywordflow">if</span> (pTotAcesAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) <span class="comment">// existe prox total</span>
00615          GerAcessos.LTotAcessos[pTotAcesAux].ant =
00616                                     GerAcessos.LTotAcessos[pTotAces].ant;
00617 
00618       <span class="comment">// insere total atual na lista de dispo</span>
00619       GerAcessos.LTotAcessos[pTotAces].TotAcessos = 0;
00620       GerAcessos.LTotAcessos[pTotAces].ant = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00621       GerAcessos.LTotAcessos[pTotAces].frontFilaPg =
00622                      GerAcessos.LTotAcessos[pTotAces].rearFilaPg = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00623       GerAcessos.LTotAcessos[pTotAces].prox = GerAcessos.LDispo;
00624       GerAcessos.LDispo = pTotAces;
00625    }<span class="keywordflow">else</span> { <span class="comment">// existe mais de uma pg na fila</span>
00626       pPgAux = ListaPgs.Pagina[pPg].antDaFila;
00627 
00628       <span class="comment">// testa se existe pagina anterior na fila - nao e a primeira</span>
00629       <span class="keywordflow">if</span> (pPgAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>)
00630          ListaPgs.Pagina[pPgAux].proxDaFila = ListaPgs.Pagina[pPg].proxDaFila;
00631       <span class="keywordflow">else</span>  <span class="comment">// nao existe pagina anterior na fila - e a primeira</span>
00632          GerAcessos.LTotAcessos[pTotAces].rearFilaPg =
00633                                            ListaPgs.Pagina[pPg].proxDaFila;
00634 
00635       pPgAux = ListaPgs.Pagina[pPg].proxDaFila;
00636       <span class="keywordflow">if</span> (pPgAux != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) <span class="comment">// existe prox pagina - nao e a ultima</span>
00637          ListaPgs.Pagina[pPgAux].antDaFila = ListaPgs.Pagina[pPg].antDaFila;
00638       <span class="keywordflow">else</span> <span class="comment">// nao existe prox pagina - e a ultima</span>
00639          GerAcessos.LTotAcessos[pTotAces].frontFilaPg =
00640                                           ListaPgs.Pagina[pPg].antDaFila;
00641 
00642    }<span class="comment">// fim do if</span>
00643    ListaPgs.Pagina[pPg].proxDaFila =
00644                            ListaPgs.Pagina[pPg].antDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00645    ListaPgs.Pagina[pPg].IdxTotAcessos = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00646 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;:: TiraPgFila</span>
00647 
00648 <span class="comment">//==============================================================================</span>
00649 <span class="comment">// Metodo: void ColocaPgFila(unsigned int pPg, unsigned int pTotAces)</span>
00650 <span class="comment">//==============================================================================</span>
00651 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00652 <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::ColocaPgFila</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPg,
00653                                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAces) {
00654    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPgAux;
00655 
00656    pPgAux = GerAcessos.LTotAcessos[pTotAces].rearFilaPg;
00657    ListaPgs.Pagina[pPgAux].antDaFila = pPg;
00658    ListaPgs.Pagina[pPg].proxDaFila = pPgAux;
00659    GerAcessos.LTotAcessos[pTotAces].rearFilaPg = pPg;
00660    ListaPgs.Pagina[pPg].antDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00661    ListaPgs.Pagina[pPg].IdxTotAcessos = pTotAces;
00662 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::ColocaPgFila</span>
00663 
00664 <span class="comment">//==============================================================================</span>
00665 <span class="comment">// Metodo: void NovoTotal(unsigned int pPg, unsigned int pTotAces)</span>
00666 <span class="comment">//==============================================================================</span>
00667 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00668 <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::NovoTotal</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pPg, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;pTotAces) {
00669    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAcesNovo;
00670    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pTotAcesProx;
00671 
00672    <span class="comment">// obtem um TotAcess dispo</span>
00673    pTotAcesNovo = GerAcessos.LDispo;
00674    GerAcessos.LDispo = GerAcessos.LTotAcessos[pTotAcesNovo].prox;
00675 
00676    <span class="comment">// insere novo TotAcess na lista</span>
00677    GerAcessos.LTotAcessos[pTotAcesNovo].TotAcessos = 1 +
00678           GerAcessos.LTotAcessos[pTotAces].TotAcessos;
00679    GerAcessos.LTotAcessos[pTotAcesNovo].ant  = pTotAces;
00680    pTotAcesProx = GerAcessos.LTotAcessos[pTotAcesNovo].prox =
00681              GerAcessos.LTotAcessos[pTotAces].prox;
00682    GerAcessos.LTotAcessos[pTotAces].prox = pTotAcesNovo;
00683    <span class="keywordflow">if</span> (pTotAcesProx != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) <span class="comment">// o total atual nao era o ultimo</span>
00684       GerAcessos.LTotAcessos[pTotAcesProx].ant = pTotAcesNovo;
00685 
00686    <span class="comment">// insere pPg no novo total</span>
00687    GerAcessos.LTotAcessos[pTotAcesNovo].frontFilaPg =
00688           GerAcessos.LTotAcessos[pTotAcesNovo].rearFilaPg = pPg;
00689    ListaPgs.Pagina[pPg].proxDaFila =
00690          ListaPgs.Pagina[pPg].antDaFila = <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>;
00691    ListaPgs.Pagina[pPg].IdxTotAcessos = pTotAcesNovo;
00692 
00693    pTotAces = pTotAcesNovo; <span class="comment">// retorna o novo pTotAces</span>
00694 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::NovoTotal</span>
00695 
00696 <span class="comment">//==============================================================================</span>
00697 <span class="comment">// Metodo: ~CNSCache()</span>
00698 <span class="comment">//==============================================================================</span>
00699 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00700 <span class="keywordtype">void</span> <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::UnMountCache</a>() {
00701    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
00702 
00703    <a class="code" href="classCNSCache.html#a6">FlushCache</a>();
00704 
00705    <span class="comment">// liberando TME</span>
00706    <span class="keywordflow">for</span> (i = 0; i &lt; N_PAGINAS; <span class="keyword">delete</span>[] TME.Bloco[i++].pPagina);
00707 
00708    <span class="keyword">delete</span>[] TME.Bloco;
00709    <span class="keyword">delete</span>[] TME.pBloco;
00710 
00711    <span class="comment">// liberando ListaPgs</span>
00712    <span class="keywordflow">for</span> (i = 0; i &lt; N_PAGINAS; <span class="keyword">delete</span>[] ListaPgs.Pagina[i++].Page);
00713 
00714    <span class="keyword">delete</span>[] ListaPgs.Pagina;
00715 
00716    <span class="comment">// liberando GerAcessos</span>
00717    <span class="keyword">delete</span>[] GerAcessos.LTotAcessos;
00718 
00719    ObjContinente = NULL;
00720 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::UnMountCache</span>
00721 
00722 <span class="preprocessor">#ifdef CNSCACHE_CHECK</span>
00723 <span class="preprocessor"></span><span class="comment">//==============================================================================</span>
00724 <span class="comment">// Metodo:</span>
00725 <span class="comment">//==============================================================================</span>
00726 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TpObjCntin&gt;
00727 <a class="code" href="classCNSCache.html">CNSCache&lt;TpObjCntin&gt;::checkStructure</a>() {
00728    <span class="keywordtype">int</span> pBlocoE, <span class="comment">// entrada no vetor pBloco</span>
00729       blocoE, <span class="comment">// entrada no vetor TME.Bloco[]</span>
00730       paginasChecadas = 0, <span class="comment">// contador de paginas checadas</span>
00731       blocosChecados = 0; <span class="comment">// contador de blocos checados</span>
00732 
00733    checkCounter++;
00734 
00735    <span class="comment">// ===========================================================================</span>
00736    <span class="comment">// confere TME</span>
00737    <span class="comment">// ===========================================================================</span>
00738    <span class="comment">// Verificar se o bloco que esta ativado (diferente de CNSCACHE_NIL) esta</span>
00739    <span class="comment">// realmente sendo usado e se a pagina referente a cada entrada nesse bloco</span>
00740    <span class="comment">// esta realmente apontando para ele. Alem disso, cada pagina checada sera</span>
00741    <span class="comment">// contada, se o numero de paginas checadas for diferente de N_PAGINAS, erro.</span>
00742    <span class="comment">// Em seguida, a lista de blocos disponiveis sera checada. O numero de blocos</span>
00743    <span class="comment">// na lista de disponiveis somado ao numero de blocos ativos tem que ser igual</span>
00744    <span class="comment">// a N_PAGINAS. Nao ha a necessidade de contar o numero de entradas inativas</span>
00745    <span class="comment">// no vetor pBlocos, pois elas nao estao listadas e, se ela estiver ativada</span>
00746    <span class="comment">// e apontando para um bloco invalido, a checagem da pagina ira detectar isso.</span>
00747 
00748    <span class="keywordflow">for</span> (pBlocoE = 0; pBlocoE &lt; TME.TotBlocos; pBlocoE++) {
00749       <span class="keywordflow">if</span> (TME.pBloco[pBlocoE] != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00750          <span class="keywordtype">int</span> pPagina, pgChecadaLocal = 0;
00751 
00752          blocoE = TME.pBloco[pBlocoE]; <span class="comment">// entrada no vetor TME.Bloco</span>
00753          blocosChecados++;
00754          <span class="keywordflow">if</span> (!TME.Bloco[blocoE].RgsUsados) { <span class="comment">// esta ativo mas nao aponta nenhuma</span>
00755                                              <span class="comment">//  pagina</span>
00756             printf(<span class="stringliteral">"Erro em TME.Bloco[blocoE].RgsUsados."</span>
00757                    <span class="stringliteral">" checkcounter = %ld\n"</span>, checkCounter);
00758             exit(1);
00759          }<span class="comment">//end if</span>
00760 
00761          <span class="keywordflow">for</span> (pPagina = 0; pPagina &lt; RGS_POR_BLOCO; pPagina++) {
00762             <span class="keywordtype">int</span> pg = TME.Bloco[blocoE].pPagina[pPagina];
00763             <span class="keywordflow">if</span> (pg != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00764                pgChecadaLocal++;
00765                paginasChecadas++;
00766 
00767                <span class="keywordflow">if</span>((pblocoE != (ListaPgs.Pagina[pg].IdRegFisico &gt;&gt; F_ROTACAO)) {
00768                   printf(<span class="stringliteral">"Erro em ListaPgs.Pagina[pg].IdRegFisico &gt;&gt; F_ROTACAO."</span>
00769                          <span class="stringliteral">" checkcounter = %ld\n"</span>, checkCounter);
00770                   exit(1);
00771                }<span class="comment">//end if</span>
00772                <span class="keywordflow">if</span>((blocoE != (ListaPgs.Pagina[pg].IdRegFisico -
00773                   (pblocoE &lt;&lt; F_ROTACAO)) {
00774                   printf(<span class="stringliteral">"Erro em ListaPgs.Pagina[pg].IdRegFisico - (pblocoE &lt;&lt; "</span>
00775                          <span class="stringliteral">"F_ROTACAO. checkcounter = %ld\n"</span>, checkCounter);
00776                   exit(1);
00777                }<span class="comment">//end if</span>
00778             }<span class="comment">//end if</span>
00779          }<span class="comment">//end for</span>
00780          <span class="comment">// garantido que todas as paginas apontam para os blocos que apontam</span>
00781          <span class="comment">// para elas.</span>
00782          <span class="keywordflow">if</span> (TME.Bloco[blocoE].RgsUsados != pgChecadaLocal) {
00783             printf(<span class="stringliteral">"Erro em TME.Bloco[blocoE].RgsUsados != pgChecadaLocal."</span>
00784                    <span class="stringliteral">" checkcounter = %ld\n"</span>, checkCounter);
00785             exit(1);
00786          }<span class="comment">//end if</span>
00787       } <span class="comment">// garantido que todas as paginas apontadas por um bloco sao validas,</span>
00788         <span class="comment">// que elas apontam para eles mesmos, e que o numero de paginas apontas</span>
00789         <span class="comment">// por eles eh o numero indicado em RgsUsados</span>
00790    } <span class="comment">// garantido que os blocos ativos apontam alguma(s) pagina(s), que</span>
00791      <span class="comment">// esta(s) pagina(s) aponta(m) para o mesmo bloco que a(s) aponta(m), e</span>
00792      <span class="comment">// que o suposto numero de paginas apontadas (RgsUsados) esta correto.</span>
00793    <span class="comment">// checando TME.LBlocoDispo</span>
00794    blocoE = TME.LBlocoDispo;
00795    <span class="keywordflow">while</span> (blocoE != <a class="code" href="CNSCache_8h.html#a1">CNSCACHE_NIL</a>) {
00796       blocosChecados++;
00797       blocoE = TME.Bloco[blocoE].pPagina[0];
00798    }<span class="comment">//end while</span>
00799    <span class="keywordflow">if</span> (blocosChecados != N_PAGINAS) {
00800       printf(<span class="stringliteral">"Erro em blocosChecados != N_PAGINAS."</span>
00801              <span class="stringliteral">" checkcounter = %ld\n"</span>, checkCounter);
00802       exit(1);
00803    }<span class="comment">//end if</span>
00804    <span class="comment">// garantido que todos os blocos que nao estao ativos estao na lista de</span>
00805    <span class="comment">// disponiveis. Por consequencia, a lista de disponiveis esta corretamente</span>
00806    <span class="comment">// encadeada</span>
00807 
00808 }<span class="comment">//end CNSCache&lt;TpObjCntin&gt;::checkStructure</span>
00809 
00810 <span class="preprocessor">#endif // CNSCACHE_CHECK</span>
00811 <span class="preprocessor"></span>
00812 <span class="preprocessor">#endif // CNSCACHEH</span>
</pre></div><hr><address style="align: right;"><small>
Generated on Mon Mar 21 16:12:05 2005 for GBDI Arboretum by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.3.4</small><br>
Copyright &copy 2002-2003 GBDI-ICMC-USP
</address>
</body>
</html>
